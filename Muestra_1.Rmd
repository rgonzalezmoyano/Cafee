---
title: "Clasificadores de eficiencia"
subtitle: "Diferentes hiperplanos para la clasificiación de la eficiencia"
author: "Ricardo González Moyano & Víctor Javier España Roch"
date: "26 de Septiembre de 2023"
output:
  rmdformats::readthedown:
    embed_resources: true
    standalone: true
    mathjax: true
---

```{librerias}
devtools::load_all()
library(ggplot2)

set.seed(314)
```

# Gráfico mejor hiperplano separador

```{r modelo}
# Simulated data
data <- reffcy (
  DGP = "add_scenario_XnY1",
  parms = list (
    N = 100,
    scenario = "A"
  )
)

x <- 1
y <- 2

# efficiency orientation
orientation <- "output"

# Parameters for controlling the training process
trControl <- trainControl (
  method = "cv",
  number = 5,
  summaryFunction = twoClassSummary,
  classProbs = TRUE,
  savePredictions = "all"
)

hold_out <- 0.15

methods <- list (
  "knn" = list (
    k = 5:15
  ),
  "gbm" = list (
    n.trees = c(50, 100, 150),
    interaction.depth = c(1, 2, 3),
    shrinkage = c(0.01, 0.1, 0.2),
    n.minobsinnode = c(1, 3, 5)
  ),
  "svmRadial" = list (
    C = c(0.01, 0.1, 1, 10),
    sigma = c(0.001, 0.01, 0.1, 1)
    ),
  "svmPoly" = list(
    "degree" = c(2,3,4),
    "scale" = c(0.0001,0.001,0.01,0.1,1),
    "C" = c(seq(0.01, 100, length.out = 10), seq(200, 1000, length.out = 3))
  ),
  "rf" = list (
    mtry = c(1, 2)
    )
)

# https://topepo.github.io/caret/train-models-by-tag.html

metric = "F1"

# Result
model <- efficiency_estimation (
  data = data,
  x = x,
  y = y,
  orientation = orientation,
  trControl = trControl,
  method = methods,
  metric = metric,
  hold_out = hold_out
  )
```

```{r grafico echo = FALSE}
# Simulated data
data <- model$data

#data$class_efficiency <- ifelse(data$class_efficiency == "efficient", 1, 0)
#data$class_efficiency <- as.factor(data$class_efficiency)

# hiperplano
# make a grid of the predictors
rng.x <- range(data[1])
rng.y <- range(data[2])

n_points <- 50
grid <- expand.grid(x1 = seq(rng.x[1], rng.x[2], length = n_points),
                    y = seq(rng.y[1], rng.y[2], length = n_points))

grid$decision <- predict(model$final_model, grid, type = "raw")


# Contriur hiperplano
rango_X1 <- range(min(data[x]), max(data[x]))

#rango_X2 <- range(0, 5.7)
rango_X2 <- range(min(prueba$data[y]), max(prueba$data[y]))

# Interpolación de puntos
new_x1 <- seq(from = rango_X1[1], to = rango_X1[2], length = 200)
new_x2 <- seq(from = rango_X2[1], to = rango_X2[2], length = 200)
nuevos_puntos <- expand.grid(x1 = new_x1, y = new_x2)

# Predicción según el modelo
predicciones <- predict(object = prueba$final_model, newdata = nuevos_puntos)

ggplot(data = data) +
  geom_point(data = grid, aes(x = x1, y = y, color = decision), size = 0.75) +
  theme_bw()
```

