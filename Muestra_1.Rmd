---
title: "Clasificadores de eficiencia"
subtitle: "Diferentes hiperplanos para la clasificiación de la eficiencia"
author: "Ricardo González Moyano & Víctor Javier España Roch"
date: "26 de Septiembre de 2023"
output:
  rmdformats::readthedown:
    embed_resources: true
    standalone: true
    mathjax: true
---

```{r librerias}
devtools::load_all()
library(ggplot2)

set.seed(314)
```

```{r rad_out, include=FALSE}
rad_out <- function (
    tech_xmat, tech_ymat, eval_xmat, eval_ymat, convexity, returns
    ) {

  # number of DMUs in the technology
  tech_dmu <- nrow(tech_xmat)

  # number of DMUs to be evaluated
  eval_dmu <- nrow(eval_xmat)

  # initialize vector of scores
  scores <- matrix(nrow = eval_dmu, ncol = 1)

  # number of inputs and outputs
  nX <- ncol(tech_xmat)
  nY <- ncol(tech_ymat)

  for (d in 1:eval_dmu) {

    objVal <- matrix(ncol = 1 + tech_dmu, nrow = 1)
    objVal[1] <- 1

    lps <- make.lp(nrow = 0, ncol = 1 + tech_dmu)
    lp.control(lps, sense = 'max')
    set.objfn(lps, objVal)

    # inputs
    for (xi in 1:nX) {
      add.constraint(lps, xt = c(0, tech_xmat[, xi]), "<=",  rhs = eval_xmat[d, xi])
    }

    # outputs
    for (yi in 1:nY) {
      add.constraint(lps, xt = c(- eval_ymat[d, yi], tech_ymat[, yi]), ">=", rhs = 0)
    }

    # technology
    if (returns == "variable") {
      if (convexity) {
        add.constraint(lprec = lps, xt = c(0, rep(1, tech_dmu)), type = "=", rhs = 1)
      } else {
        add.constraint(lprec = lps, xt = c(0, rep(1, tech_dmu)), type = "=", rhs = 1)
        set.type(lps, columns = 1:tech_dmu + 1, type = c("binary"))
      }
    }

    solve(lps)
    scores[d, ] <- get.objective(lps)
  }

  return(scores)
}
```

# Gráfico mejor hiperplano separador

```{r modelo, message=FALSE, warning=FALSE}
# ============== #
# Simulated data #
# ============== #

data <- reffcy (
  DGP = "add_scenario_XnY1",
  parms = list (
    N = 200,
    scenario = "A"
  )
)

x <- 1
y <- 2

# ============== #
# DEA estimation #
# ============== #

tech_xmat <- as.matrix(data[, x])
tech_ymat <- as.matrix(data[, y])
eval_xmat <- as.matrix(data[, x])
eval_ymat <- as.matrix(data[, y])

bcc_scores <- rad_out (
  tech_xmat = tech_xmat,
  tech_ymat = tech_ymat,
  eval_xmat = eval_xmat,
  eval_ymat = eval_ymat,
  convexity = TRUE,
  returns = "variable"
)

dea_proj <- as.data.frame(data$y * bcc_scores)
data$dea <- dea_proj$V1

# ======== #
# ML model #
# ======== #

# efficiency orientation
orientation <- "output"

# Parameters for controlling the training process
trControl <- trainControl (
  method = "cv",
  number = 5,
  summaryFunction = twoClassSummary,
  classProbs = TRUE,
  savePredictions = "all"
)

hold_out <- 0.15

methods <- list (
  "knn" = list (
    k = 1:3
  ),
  "gbm" = list (
    n.trees = c(50, 100, 150),
    interaction.depth = c(1, 2, 3),
    shrinkage = c(0.01, 0.1, 0.2),
    n.minobsinnode = c(1, 3, 5)
  ),
  "svmRadial" = list (
    C = c(0.01, 0.1, 1, 10),
    sigma = c(0.001, 0.01, 0.1, 1)
    ),
  "svmPoly" = list(
    "degree" = c(2, 3, 4),
    "scale" = c(0.0001, 0.001, 0.01, 0.1, 1),
    "C" = c(seq(0.01, 100, length.out = 10), seq(200, 1000, length.out = 3))
  ),
  "rf" = list (
    mtry = c(1, 2)
    )
)

# https://topepo.github.io/caret/train-models-by-tag.html

metric = "F1"

# Result
model <- efficiency_estimation (
  data = data,
  x = x,
  y = y,
  orientation = orientation,
  trControl = trControl,
  method = methods,
  metric = metric,
  hold_out = hold_out
  )
```

```{r}
model
```

```{r grafico, echo = FALSE}
# make a grid of the predictors
rng.x <- range(data[1])
rng.y <- range(data[2])

grid <- expand.grid (
  x1 = seq(rng.x[1], rng.x[2], length = 150),
  y = seq(rng.y[1], rng.y[2], length = 150)
  )

grid$decision <- predict(model, grid, type = "raw")

ggplot(data = data) +
  geom_point(data = grid, aes(x = x1, y = y, color = decision), size = 0.75, alpha = 0.5) +
  geom_line(aes(x = x1, y = yD), linewidth = 1) +
  geom_line(aes(x = x1, y = dea), linewidth = 1) +
  scale_color_manual(values = c("not_efficient" = "pink", "efficient" = "lightgreen")) +
  theme_bw() +
  theme(
    axis.title.x = element_text (
      size = 12, face = "bold", color = "#921F30",
      margin = margin(t = 10)),
    axis.title.y = element_text (
      size = 12, face = "bold", color = "#921F30",
      margin = margin(r = 10)),
    axis.text = element_text (
      size = 12, color = "black"),
    plot.margin = unit(c(1.25, 1.25, 1.25, 1.25), "lines"),
    plot.title = element_text (
      size = 12, face = "bold", color = "#921F30",
      margin = margin(b = 10)
    ),
    legend.position = "none"
  )
```